"use strict";(self.webpackChunkplatformatic_oss_website=self.webpackChunkplatformatic_oss_website||[]).push([[28565],{17129:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var o=t(85893),i=t(11151);const s={},a="Use Stackables to build Platformatic applications",r={id:"guides/applications-with-stackables",title:"Use Stackables to build Platformatic applications",description:"Platformatic Service and Platformatic DB",source:"@site/versioned_docs/version-1.15.1/guides/applications-with-stackables.md",sourceDirName:"guides",slug:"/guides/applications-with-stackables",permalink:"/docs/1.15.1/guides/applications-with-stackables",draft:!1,unlisted:!1,editUrl:"https://github.com/platformatic/oss/edit/main/versioned_docs/version-1.15.1/guides/applications-with-stackables.md",tags:[],version:"1.15.1",frontMatter:{},sidebar:"docs",previous:{title:"Migrating an Express app to Platformatic Service",permalink:"/docs/1.15.1/guides/migrating-express-app-to-platformatic-service"},next:{title:"Telemetry with Jaeger",permalink:"/docs/1.15.1/guides/telemetry"}},c={},l=[{value:"Creating a custom Service",id:"creating-a-custom-service",level:2},{value:"Consuming a custom application",id:"consuming-a-custom-application",level:2},{value:"Building your own CLI",id:"building-your-own-cli",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"use-stackables-to-build-platformatic-applications",children:"Use Stackables to build Platformatic applications"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"/docs/next/reference/db/introduction",children:"Platformatic Service"})," and ",(0,o.jsx)(n.a,{href:"/docs/next/reference/db/introduction",children:"Platformatic DB"}),'\noffer a good starting point to create new applications. However, most developers or organizations might want to\ncreate reusable services or applications built on top of Platformatic.\nWe call these reusable services "Stackables" because you can create an application by stacking services on top of them.']}),"\n",(0,o.jsx)(n.p,{children:"This is useful to publish the application on the public npm registry (or a private one!), including building your own CLI,\nor to create a specialized template for your organization to allow for centralized bugfixes and updates."}),"\n",(0,o.jsx)(n.p,{children:"This process is the same one we use to maintain Platformatic DB and Platformatic Composer on top of Platformatic Service."}),"\n",(0,o.jsx)(n.h2,{id:"creating-a-custom-service",children:"Creating a custom Service"}),"\n",(0,o.jsxs)(n.p,{children:["We are creating the stackable ",(0,o.jsx)(n.code,{children:"foo.js"})," as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const { schema, platformaticService } = require('@platformatic/service')\n\n/**  @type {import('fastify').FastifyPluginAsync<{}>} */\nasync function foo (app, opts) {\n  const text = app.platformatic.config.foo.text\n  app.get('/foo', async (request, reply) => {\n    return text\n  })\n\n  await app.register(platformaticService, opts)\n\n  app.get('/', async (request, reply) => {\n    return 'Your new root endpoint'\n  })\n}\n\nfoo.configType = 'foo'\n\n// break Fastify encapsulation\nfoo[Symbol.for('skip-override')] = true\n\n// The schema for our configuration file\nfoo.schema = {\n  $id: 'https://example.com/schemas/foo.json',\n  title: 'Foo Service',\n  type: 'object',\n  properties: {\n    server: schema.server,\n    plugins: schema.plugins,\n    metrics: schema.metrics,\n    watch: {\n      anyOf: [schema.watch, {\n        type: 'boolean'\n      }, {\n        type: 'string'\n      }]\n    },\n    $schema: {\n      type: 'string'\n    },\n    extends: {\n      type: 'string'\n    },\n    foo: {\n      type: 'object',\n      properties: {\n        text: {\n          type: 'string'\n        }\n      },\n      required: ['text']\n    }\n  },\n  additionalProperties: false,\n  required: ['server']\n}\n\n// The configuration for the ConfigManager\nfoo.configManagerConfig = {\n  schema: foo.schema,\n  envWhitelist: ['PORT', 'HOSTNAME'],\n  allowToWatch: ['.env'],\n  schemaOptions: {\n    useDefaults: true,\n    coerceTypes: true,\n    allErrors: true,\n    strict: false\n  }\n}\n\nmodule.exports = foo\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Note that the ",(0,o.jsx)(n.code,{children:"$id"})," property of the schema identifies the module in our system,\nallowing us to retrieve the schema correctly.\nIt is recommended, but not required, that the JSON schema is actually\npublished in this location. Doing so allows tooling such as the VSCode\nlanguage server to provide autocompletion."]}),"\n",(0,o.jsxs)(n.p,{children:["In this example, the ",(0,o.jsx)(n.code,{children:"schema"})," adds a custom top-level ",(0,o.jsx)(n.code,{children:"foo"})," property\nthat users can use to configure this specific module."]}),"\n",(0,o.jsx)(n.p,{children:"ESM is also supported."}),"\n",(0,o.jsx)(n.h2,{id:"consuming-a-custom-application",children:"Consuming a custom application"}),"\n",(0,o.jsxs)(n.p,{children:["Consuming ",(0,o.jsx)(n.code,{children:"foo.js"})," is simple. We can create a ",(0,o.jsx)(n.code,{children:"platformatic.json"})," file as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",children:'{\n  "$schema": "https://example.com/schemas/foo.json",\n  "extends": "./foo",\n  "server": {\n    "port": 0,\n    "hostname": "127.0.0.1"\n  },\n  "foo": {\n    "text": "Hello World"\n  }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Note that we ",(0,o.jsx)(n.strong,{children:"must"})," specify both the ",(0,o.jsx)(n.code,{children:"$schema"})," property and ",(0,o.jsx)(n.code,{children:"extends"}),".\nThe module specified with ",(0,o.jsx)(n.code,{children:"extends"})," can also be any modules published on npm and installed via your package manager."]}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"extends"}),' is the name of the module we are actually "stacking" (extending) on top of.\nThe property ',(0,o.jsx)(n.code,{children:"module"})," can also be used, but it is deprecated. In both cases, be sure that the property is allowed in the stackable schema (in this example in ",(0,o.jsx)(n.code,{children:"foo.schema"}),")"]})}),"\n",(0,o.jsx)(n.h2,{id:"building-your-own-cli",children:"Building your own CLI"}),"\n",(0,o.jsx)(n.p,{children:"If you want to create your own CLI for your service on top of a Stackable you can just importing the base module and then start it, e.g.:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import base from 'mybasemodule' // Import here your base module\nimport { start } from '@platformatic/service'\nimport { printAndExitLoadConfigError } from '@platformatic/config'\n\nawait start(base, process.argv.splice(2)).catch(printAndExitLoadConfigError)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This is the same as running with platformatic CLI, the ",(0,o.jsx)(n.code,{children:"platformatic.json"})," file will be loaded from the current directory."]})]})}function d(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>a});var o=t(67294);const i={},s=o.createContext(i);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);